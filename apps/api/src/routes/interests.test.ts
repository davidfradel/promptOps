import { describe, it, expect, vi, beforeEach } from 'vitest';
import express from 'express';

vi.mock('../lib/prisma.js', () => ({
  prisma: {
    user: { findUnique: vi.fn() },
    userInterest: {
      findMany: vi.fn(),
      createMany: vi.fn(),
      deleteMany: vi.fn(),
    },
    project: {
      findFirst: vi.fn(),
      create: vi.fn(),
      deleteMany: vi.fn(),
    },
    source: { create: vi.fn() },
    scrapeJob: { create: vi.fn() },
  },
}));

vi.mock('../services/queue/jobs.js', () => ({
  enqueueScrapeJob: vi.fn().mockResolvedValue('job-1'),
}));

vi.mock('../data/category-sources.js', () => ({
  CATEGORY_SOURCES: {
    SAAS: [{ platform: 'REDDIT', url: 'https://www.reddit.com/r/SaaS' }],
  } as Record<string, { platform: string; url: string }[]>,
}));

vi.mock('../lib/auth.js', () => ({
  verifyToken: vi.fn().mockReturnValue({ userId: 'user-1' }),
}));

vi.mock('../utils/logger.js', () => ({
  logger: { info: vi.fn(), error: vi.fn(), warn: vi.fn(), debug: vi.fn() },
}));

import { prisma } from '../lib/prisma.js';
import { enqueueScrapeJob } from '../services/queue/jobs.js';
import { interestsRouter } from './interests.js';
import { authMiddleware } from '../middleware/auth.js';
import { errorHandler } from '../middleware/error-handler.js';
import { mockUser, mockProject, mockSource, authHeaders, request } from '../test/helpers.js';

function createAuthTestApp() {
  const app = express();
  app.use(express.json());
  app.use(authMiddleware);
  app.use('/', interestsRouter);
  app.use(errorHandler);
  return app;
}

describe('interests routes', () => {
  let app: express.Express;

  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(prisma.user.findUnique).mockResolvedValue(mockUser());
    app = createAuthTestApp();
  });

  describe('GET /', () => {
    it('should return user interests', async () => {
      const interests = [
        { id: 'int-1', userId: 'user-1', category: 'SAAS', createdAt: new Date() },
        { id: 'int-2', userId: 'user-1', category: 'DEVTOOLS', createdAt: new Date() },
      ];
      vi.mocked(prisma.userInterest.findMany).mockResolvedValue(interests as never);

      const res = await request(app, 'GET', '/', undefined, authHeaders());

      expect(res.status).toBe(200);
      expect(res.body.data).toHaveLength(2);
    });
  });

  describe('PATCH /', () => {
    it('should add interests and create projects/sources', async () => {
      vi.mocked(prisma.userInterest.createMany).mockResolvedValue({ count: 1 } as never);
      vi.mocked(prisma.project.findFirst).mockResolvedValue(null);
      vi.mocked(prisma.project.create).mockResolvedValue(mockProject({ id: 'proj-new' }));
      vi.mocked(prisma.source.create).mockResolvedValue(mockSource({ id: 'src-new' }));
      vi.mocked(prisma.scrapeJob.create).mockResolvedValue({ id: 'job-new' } as never);
      vi.mocked(prisma.userInterest.findMany).mockResolvedValue([
        { id: 'int-1', userId: 'user-1', category: 'SAAS', createdAt: new Date() },
      ] as never);

      const res = await request(app, 'PATCH', '/', { add: ['SAAS'], remove: [] }, authHeaders());

      expect(res.status).toBe(200);
      expect(prisma.userInterest.createMany).toHaveBeenCalled();
      expect(prisma.project.create).toHaveBeenCalled();
      expect(prisma.source.create).toHaveBeenCalled();
      expect(enqueueScrapeJob).toHaveBeenCalled();
    });

    it('should remove interests and delete associated projects', async () => {
      vi.mocked(prisma.userInterest.deleteMany).mockResolvedValue({ count: 1 } as never);
      vi.mocked(prisma.project.deleteMany).mockResolvedValue({ count: 1 } as never);
      vi.mocked(prisma.userInterest.findMany).mockResolvedValue([]);

      const res = await request(app, 'PATCH', '/', { add: [], remove: ['SAAS'] }, authHeaders());

      expect(res.status).toBe(200);
      expect(prisma.userInterest.deleteMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: { userId: 'user-1', category: { in: ['SAAS'] } },
        }),
      );
      expect(prisma.project.deleteMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: { userId: 'user-1', isAutoGenerated: true, category: { in: ['SAAS'] } },
        }),
      );
    });

    it('should add and remove interests together', async () => {
      vi.mocked(prisma.userInterest.deleteMany).mockResolvedValue({ count: 1 } as never);
      vi.mocked(prisma.project.deleteMany).mockResolvedValue({ count: 1 } as never);
      vi.mocked(prisma.userInterest.createMany).mockResolvedValue({ count: 1 } as never);
      vi.mocked(prisma.project.findFirst).mockResolvedValue(null);
      vi.mocked(prisma.project.create).mockResolvedValue(mockProject({ id: 'proj-new' }));
      vi.mocked(prisma.source.create).mockResolvedValue(mockSource({ id: 'src-new' }));
      vi.mocked(prisma.scrapeJob.create).mockResolvedValue({ id: 'job-new' } as never);
      vi.mocked(prisma.userInterest.findMany).mockResolvedValue([
        { id: 'int-1', userId: 'user-1', category: 'SAAS', createdAt: new Date() },
      ] as never);

      const res = await request(
        app,
        'PATCH',
        '/',
        { add: ['SAAS'], remove: ['DEVTOOLS'] },
        authHeaders(),
      );

      expect(res.status).toBe(200);
      expect(prisma.userInterest.deleteMany).toHaveBeenCalled();
      expect(prisma.userInterest.createMany).toHaveBeenCalled();
    });
  });
});
