import { describe, it, expect, vi, beforeEach } from 'vitest';
import { extractInsightsAndCompetitors } from './extract-insights.js';

vi.mock('../../lib/prisma.js', () => ({
  prisma: {
    project: { findUniqueOrThrow: vi.fn() },
    source: { findMany: vi.fn() },
    rawPost: { findMany: vi.fn() },
    insight: {
      findMany: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
    },
    insightSource: {
      create: vi.fn(),
      upsert: vi.fn(),
    },
  },
}));

vi.mock('../../lib/redis.js', () => ({
  redis: {
    get: vi.fn().mockResolvedValue(null),
    setex: vi.fn().mockResolvedValue('OK'),
  },
}));

vi.mock('../../utils/claude.js', () => ({
  askClaude: vi.fn(),
}));

vi.mock('../../utils/logger.js', () => ({
  logger: { info: vi.fn(), error: vi.fn(), warn: vi.fn(), debug: vi.fn() },
}));

import { prisma } from '../../lib/prisma.js';
import { redis } from '../../lib/redis.js';
import { askClaude } from '../../utils/claude.js';

const makeProject = (overrides = {}) => ({
  id: 'proj-1',
  name: 'TestProject',
  niche: 'SaaS',
  keywords: [],
  isAutoGenerated: false,
  userId: 'user-1',
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
});

const makePost = (id: string, overrides = {}) => ({
  id,
  sourceId: 'src-1',
  externalId: id,
  platform: 'REDDIT',
  title: `Title ${id}`,
  body: `Body ${id}`,
  author: 'user',
  url: null,
  score: 10,
  postedAt: new Date(),
  metadata: null,
  createdAt: new Date(),
  ...overrides,
});

const validClaudeResponse = JSON.stringify({
  insights: [
    {
      type: 'PAIN_POINT',
      title: 'Auth is broken',
      description: 'Users cannot log in. It is very frustrating.',
      severity: 0.8,
      confidence: 0.9,
      tags: ['auth'],
      sourcePostIds: ['post-1'],
    },
  ],
  competitors: [
    {
      type: 'COMPETITOR',
      title: 'CompetitorX',
      description: 'A competing product. It has better UX.',
      severity: 0.6,
      confidence: 0.7,
      tags: ['competitor'],
      sourcePostIds: ['post-1'],
      metadata: {
        competitorName: 'CompetitorX',
        strengths: ['UX'],
        weaknesses: ['price'],
        marketPosition: 'leader',
        threatLevel: 'HIGH',
      },
    },
  ],
});

describe('extractInsightsAndCompetitors', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(prisma.project.findUniqueOrThrow).mockResolvedValue(makeProject() as never);
    vi.mocked(prisma.source.findMany).mockResolvedValue([{ id: 'src-1' } as never]);
    vi.mocked(prisma.rawPost.findMany).mockResolvedValue([makePost('post-1')] as never);
    vi.mocked(prisma.insight.findMany).mockResolvedValue([]);
    vi.mocked(prisma.insight.create).mockResolvedValue({ id: 'ins-1' } as never);
    vi.mocked(prisma.insightSource.create).mockResolvedValue({} as never);
    vi.mocked(redis.get).mockResolvedValue(null);
    vi.mocked(askClaude).mockResolvedValue(validClaudeResponse);
  });

  it('returns early when no sources found', async () => {
    vi.mocked(prisma.source.findMany).mockResolvedValue([]);

    await extractInsightsAndCompetitors('proj-1');

    expect(askClaude).not.toHaveBeenCalled();
  });

  it('returns early when no posts found', async () => {
    vi.mocked(prisma.rawPost.findMany).mockResolvedValue([]);

    await extractInsightsAndCompetitors('proj-1');

    expect(askClaude).not.toHaveBeenCalled();
  });

  it('skips Claude when cache hit', async () => {
    vi.mocked(redis.get).mockResolvedValue('1');

    await extractInsightsAndCompetitors('proj-1');

    expect(askClaude).not.toHaveBeenCalled();
    expect(prisma.insight.create).not.toHaveBeenCalled();
  });

  it('calls Claude and creates insights + competitors', async () => {
    await extractInsightsAndCompetitors('proj-1');

    expect(askClaude).toHaveBeenCalledOnce();
    expect(askClaude).toHaveBeenCalledWith(
      expect.stringContaining('competitive intelligence'),
      expect.stringContaining('post-1'),
      expect.objectContaining({ temperature: 0.3, maxTokens: 8192 }),
    );
    expect(prisma.insight.create).toHaveBeenCalledTimes(2); // 1 insight + 1 competitor
    expect(prisma.insightSource.create).toHaveBeenCalledTimes(2);
  });

  it('caches result after successful analysis', async () => {
    await extractInsightsAndCompetitors('proj-1');

    expect(redis.setex).toHaveBeenCalledWith(
      expect.stringContaining('analysis:proj-1:'),
      6 * 3600,
      '1',
    );
  });

  it('strips markdown fences from Claude response', async () => {
    vi.mocked(askClaude).mockResolvedValue('```json\n' + validClaudeResponse + '\n```');

    await extractInsightsAndCompetitors('proj-1');

    expect(prisma.insight.create).toHaveBeenCalledTimes(2);
  });

  it('throws when Claude returns invalid JSON', async () => {
    vi.mocked(askClaude).mockResolvedValue('not valid json');

    await expect(extractInsightsAndCompetitors('proj-1')).rejects.toThrow(
      'Failed to parse combined insights/competitors response',
    );
  });

  it('merges duplicate insights instead of creating new ones', async () => {
    vi.mocked(prisma.insight.findMany).mockResolvedValue([
      {
        id: 'existing-1',
        title: 'Auth is broken',
        type: 'PAIN_POINT',
        severity: 1,
        confidence: 0.7,
      } as never,
    ]);
    vi.mocked(prisma.insight.update).mockResolvedValue({} as never);
    vi.mocked(prisma.insightSource.upsert).mockResolvedValue({} as never);

    await extractInsightsAndCompetitors('proj-1');

    // The pain point duplicate should be merged (update), not created
    expect(prisma.insight.update).toHaveBeenCalledWith(
      expect.objectContaining({ where: { id: 'existing-1' } }),
    );
    // Competitor is still new
    expect(prisma.insight.create).toHaveBeenCalledTimes(1);
  });

  it('applies keyword filter when enough posts match', async () => {
    vi.mocked(prisma.project.findUniqueOrThrow).mockResolvedValue(
      makeProject({ keywords: ['auth'] }) as never,
    );
    // 15 posts: 12 contain 'auth', 3 don't → filter applied (12 >= 10)
    const matchingPosts = Array.from({ length: 12 }, (_, i) =>
      makePost(`auth-${i}`, { title: 'auth issue', body: 'auth failing' }),
    );
    const nonMatching = Array.from({ length: 3 }, (_, i) =>
      makePost(`other-${i}`, { title: 'unrelated', body: 'something else' }),
    );
    vi.mocked(prisma.rawPost.findMany).mockResolvedValue([
      ...matchingPosts,
      ...nonMatching,
    ] as never);

    await extractInsightsAndCompetitors('proj-1');

    // Claude prompt should include only auth posts (12), not the 3 unrelated
    const userPromptArg = vi.mocked(askClaude).mock.calls[0]![1];
    expect(userPromptArg).toContain('auth-0');
    expect(userPromptArg).not.toContain('other-0');
  });

  it('skips keyword filter when fewer than 10 posts match', async () => {
    vi.mocked(prisma.project.findUniqueOrThrow).mockResolvedValue(
      makeProject({ keywords: ['auth'] }) as never,
    );
    // Only 2 matching posts — filter skipped, all posts sent to Claude
    const posts = [
      makePost('auth-1', { title: 'auth issue' }),
      makePost('other-1', { title: 'unrelated' }),
      makePost('other-2', { title: 'also unrelated' }),
    ];
    vi.mocked(prisma.rawPost.findMany).mockResolvedValue(posts as never);

    await extractInsightsAndCompetitors('proj-1');

    const userPromptArg = vi.mocked(askClaude).mock.calls[0]![1];
    expect(userPromptArg).toContain('other-1');
  });

  it('includes topComments in prompt for high-engagement posts', async () => {
    vi.mocked(prisma.rawPost.findMany).mockResolvedValue([
      makePost('post-1', {
        score: 50,
        metadata: {
          numComments: 20,
          topComments: ['Great product!', 'Needs improvement'],
        },
      }),
    ] as never);

    await extractInsightsAndCompetitors('proj-1');

    const userPromptArg = vi.mocked(askClaude).mock.calls[0]![1];
    expect(userPromptArg).toContain('Community responses');
    expect(userPromptArg).toContain('Great product!');
  });

  it('omits topComments for low-engagement posts (< 15 comments)', async () => {
    vi.mocked(prisma.rawPost.findMany).mockResolvedValue([
      makePost('post-1', {
        score: 5,
        metadata: {
          numComments: 5,
          topComments: ['A comment'],
        },
      }),
    ] as never);

    await extractInsightsAndCompetitors('proj-1');

    const userPromptArg = vi.mocked(askClaude).mock.calls[0]![1];
    expect(userPromptArg).not.toContain('Community responses');
  });
});
